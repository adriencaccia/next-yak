{"version":3,"sources":["../runtime/cssLiteral.tsx","../runtime/styled.tsx","../runtime/atoms.tsx","../runtime/keyframes.tsx","../runtime/index.ts"],"sourcesContent":["import type { YakTheme } from \"./index.d.ts\";\n\ntype ComponentStyles<TProps = {}> = (props: TProps) => {\n  className: string;\n  style?: {\n    [key: string]: string;\n  };\n};\n\nexport type CSSInterpolation<TProps = {}> =\n  | string\n  | number\n  | undefined\n  | null\n  | false\n  | ComponentStyles<TProps>\n  | ((props: TProps) => CSSInterpolation<TProps>);\n\ntype CSSStyles<TProps = {}> = {\n  style: { [key: string]: string | ((props: TProps) => string) };\n};\n\ntype CSSFunction = <TProps = {}>(\n  styles: TemplateStringsArray,\n  ...values: CSSInterpolation<TProps & { theme: YakTheme }>[]\n) => ComponentStyles<TProps>;\n\ntype PropsToClassNameFn = (props: unknown) =>\n  | {\n      className?: string;\n      style?: Record<string, string>;\n    }\n  | PropsToClassNameFn;\n\n/**\n * css() runtime factory of css``\n *\n * /!\\ next-yak transpiles css`` and styled``\n *\n * This changes the typings of the css`` and styled`` functions.\n * During development the user of next-yak wants to work with the\n * typings BEFORE compilation.\n *\n * Therefore this is only an internal function only and it must be cast to any\n * before exported to the user.\n */\nconst internalCssFactory = (\n  ...args: Array<string | CSSFunction | CSSStyles<any>>\n) => {\n  const classNames: string[] = [];\n  const dynamicCssFunctions: PropsToClassNameFn[] = [];\n  const style: Record<string, string> = {};\n  for (const arg of args) {\n    // A CSS-module class name which got auto generated during build from static css\n    // e.g. css`color: red;`\n    // compiled -> css(\"yak31e4\")\n    if (typeof arg === \"string\") {\n      classNames.push(arg);\n    }\n    // Dynamic CSS e.g.\n    // css`${props => props.active && css`color: red;`}`\n    // compiled -> css((props: { active: boolean }) => props.active && css(\"yak31e4\"))\n    else if (typeof arg === \"function\") {\n      dynamicCssFunctions.push(arg as unknown as PropsToClassNameFn);\n    }\n    // Dynamic CSS with css variables e.g.\n    // css`transform: translate(${props => props.x}, ${props => props.y});`\n    // compiled -> css(\"yak31e4\", { style: { \"--yakVarX\": props => props.x }, \"--yakVarY\": props => props.y }})\n    else if (typeof arg === \"object\" && \"style\" in arg) {\n      for (const key in arg.style) {\n        const value = arg.style[key];\n        if (typeof value === \"function\") {\n          dynamicCssFunctions.push((props: unknown) => ({\n            style: {\n              [key]: String(\n                // The value for a css value can be a theme dependent function e.g.:\n                // const borderColor = (props: { theme: { mode: \"dark\" | \"light\" } }) => props.theme === \"dark\" ? \"black\" : \"white\";\n                // css`border-color: ${borderColor};`\n                // Therefore the value has to be extracted recursively\n                recursivePropExecution(props, value),\n              ),\n            },\n          }));\n        } else {\n          style[key] = value;\n        }\n      }\n    }\n  }\n\n  // Non Dynamic CSS\n  if (dynamicCssFunctions.length === 0) {\n    const className = classNames.join(\" \");\n    return () => ({ className, style });\n  }\n\n  return (props: unknown) => {\n    const allClassNames: string[] = [...classNames];\n    const allStyles: Record<string, string> = { ...style };\n    for (let i = 0; i < dynamicCssFunctions.length; i++) {\n      unwrapProps(props, dynamicCssFunctions[i], allClassNames, allStyles);\n    }\n    return {\n      className: allClassNames.join(\" \"),\n      style: allStyles,\n    };\n  };\n};\n\n// Dynamic CSS with runtime logic\nconst unwrapProps = (\n  props: unknown,\n  fn: PropsToClassNameFn,\n  classNames: string[],\n  style: Record<string, string>,\n) => {\n  let result = fn(props);\n  while (result) {\n    if (typeof result === \"function\") {\n      result = result(props);\n      continue;\n    } else if (typeof result === \"object\") {\n      if (\"className\" in result && result.className) {\n        classNames.push(result.className);\n      }\n      if (\"style\" in result && result.style) {\n        for (const key in result.style) {\n          style[key] = result.style[key];\n        }\n      }\n    }\n    break;\n  }\n};\n\nconst recursivePropExecution = (\n  props: unknown,\n  fn: (props: unknown) => any,\n): string | number => {\n  const result = fn(props);\n  if (typeof result === \"function\") {\n    return recursivePropExecution(props, result);\n  }\n  if (process.env.NODE_ENV === \"development\") {\n    if (\n      typeof result !== \"string\" &&\n      typeof result !== \"number\" &&\n      !(result instanceof String)\n    ) {\n      throw new Error(\n        `Dynamic CSS functions must return a string or number but returned ${JSON.stringify(\n          result,\n        )}`,\n      );\n    }\n  }\n  return result;\n};\n\nexport const css = internalCssFactory as any as CSSFunction;\n","import { ForwardRefRenderFunction, FunctionComponent } from \"react\";\nimport { CSSInterpolation, css } from \"./cssLiteral.js\";\nimport React from \"react\";\n\n// the following export is not relative as \"next-yak/context\"\n// links to one file for react server components and\n// to another file for classic react components\nimport { useTheme } from \"next-yak/context\";\nimport type { YakTheme } from \"./context/index.d.ts\";\n\n/**\n * Hack to hide .yak from the type definition and to deal with ExoticComponents\n */\nconst yakForwardRef: <TProps>(\n  component: ForwardRefRenderFunction<any, TProps>,\n) => FunctionComponent<TProps> = (component) =>\n  Object.assign(React.forwardRef(component), { component }) as any;\n\n/**\n * All valid html tags\n */\ntype HtmlTags = keyof JSX.IntrinsicElements;\n\n/**\n * Return type of the provided props merged with the initial props\n * where the specified props are optional\n */\ntype AttrsMerged<TBaseProps, TIn extends object = {}> = Substitute<\n  TBaseProps & { theme: YakTheme },\n  TIn\n>;\n\n/**\n * The attrs function allows to add additional props to a styled component.\n * The props can be specified as an object or as a function that receives the\n * current props as argument.\n */\ntype Attrs<\n  TBaseProps,\n  TIn extends object = {},\n  TOut extends AttrsMerged<TBaseProps, TIn> = AttrsMerged<TBaseProps, TIn>,\n> =\n  | Partial<TOut>\n  | ((p: Substitute<TBaseProps & { theme: YakTheme }, TIn>) => Partial<TOut>);\n\n//\n// The `styled()` and `styled.` API\n//\n// The API design is inspired by styled-components:\n// https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/constructors/styled.tsx\n// https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/models/StyledComponent.ts\n//\n\nconst StyledFactory = <T,>(Component: HtmlTags | FunctionComponent<T>) =>\n  Object.assign(yakStyled(Component), {\n    attrs: <\n      TAttrsIn extends object = {},\n      TAttrsOut extends AttrsMerged<T, TAttrsIn> = AttrsMerged<T, TAttrsIn>,\n    >(\n      attrs: Attrs<T, TAttrsIn, TAttrsOut>,\n    ) => yakStyled<T, TAttrsIn, TAttrsOut>(Component, attrs),\n  });\n\nconst yakStyled = <\n  T,\n  TAttrsIn extends object = {},\n  TAttrsOut extends AttrsMerged<T, TAttrsIn> = AttrsMerged<T, TAttrsIn>,\n>(\n  Component: FunctionComponent<T> | HtmlTags,\n  attrs?: Attrs<T, TAttrsIn, TAttrsOut>,\n) => {\n  return <TCSSProps extends Record<string, unknown> = {}>(\n    styles: TemplateStringsArray,\n    ...values: Array<CSSInterpolation<T & TCSSProps & { theme: YakTheme }>>\n  ) => {\n    const getRuntimeStyles = css(styles, ...values);\n    const processAttrs = (props: Substitute<TCSSProps & T, TAttrsIn>) =>\n      combineProps(\n        props,\n        typeof attrs === \"function\" ? (attrs as Function)(props) : attrs,\n      );\n    const yak = (props: Substitute<TCSSProps & T, TAttrsIn>, ref: unknown) => {\n      /** The combined props are passed into the styled`` literal functions */\n      const combinedProps: Substitute<TCSSProps & T, TAttrsIn> = processAttrs(\n        Object.assign(\n          // if the css component does not require arguments\n          // it can be call without arguments and skip calling useTheme()\n          //\n          // this is NOT against the rule of hooks as\n          // getRuntimeStyles is a constant defined outside of the component\n          //\n          // for example\n          //\n          // const Button = styled.button`color: red;`\n          //       ^ does not need to have access to theme\n          //\n          // const Button = styled.button`${({ theme }) => css`color: ${theme.color};`}`\n          //       ^ must be have acces to theme\n          attrs || getRuntimeStyles.length ? { theme: useTheme() } : {},\n          props,\n        ) as Substitute<TCSSProps & T, TAttrsIn>,\n      );\n      // execute all functions inside the style literal\n      // e.g. styled.button`color: ${props => props.color};`\n      const runtimeStyles = getRuntimeStyles(combinedProps as any);\n\n      // remove all props that start with a $ sign for string components e.g. \"button\" or \"div\"\n      // so that they are not passed to the DOM element\n      const filteredProps =\n        typeof Component === \"string\"\n          ? removePrefixedProperties(combinedProps)\n          : combinedProps;\n\n      // yak provides a className and style prop that needs to be merged with the\n      // user provided className and style prop\n      (filteredProps as { className?: string }).className = mergeClassNames(\n        (combinedProps as { className?: string }).className,\n        runtimeStyles.className as string,\n      );\n      (filteredProps as { style?: React.CSSProperties }).style =\n        \"style\" in combinedProps\n          ? {\n              ...(combinedProps as { style?: React.CSSProperties }).style,\n              ...runtimeStyles.style,\n            }\n          : runtimeStyles.style;\n      // if the styled(Component) syntax is used and the component is a yak component\n      // we can call the yak function directly to avoid an unnecessary wrapper with an additional\n      // forwardRef call\n      if (typeof Component !== \"string\" && \"yak\" in Component) {\n        return (\n          Component as typeof Component & {\n            yak: FunctionComponent<typeof combinedProps>;\n          }\n        ).yak(filteredProps, ref);\n      }\n\n      (filteredProps as { ref?: unknown }).ref = ref;\n      return <Component {...(filteredProps as any)} />;\n    };\n    return yakForwardRef(yak);\n  };\n};\n\n/**\n * Type for the proxy object returned by `styled` that allows to\n * access all html tags as properties.\n */\ntype StyledLiteral<T> = <TCSSProps extends Record<string, unknown> = {}>(\n  styles: TemplateStringsArray,\n  ...values: Array<CSSInterpolation<T & TCSSProps & { theme: YakTheme }>>\n) => FunctionComponent<TCSSProps & T>;\n\n/**\n * The `styled` method works perfectly on all of your own or any third-party component,\n * as long as they attach the passed className prop to a DOM element.\n *\n * @usage\n *\n * ```tsx\n * const StyledLink = styled(Link)`\n *  color: #BF4F74;\n *  font-weight: bold;\n * `;\n * ```\n */\nexport const styled = new Proxy(\n  StyledFactory as typeof StyledFactory & {\n    [Tag in HtmlTags]: StyledLiteral<JSX.IntrinsicElements[Tag]> & {\n      attrs: <\n        TAttrsIn extends object = {},\n        TAttrsOut extends AttrsMerged<\n          JSX.IntrinsicElements[Tag],\n          TAttrsIn\n        > = AttrsMerged<JSX.IntrinsicElements[Tag], TAttrsIn>,\n      >(\n        attrs: Attrs<JSX.IntrinsicElements[Tag], TAttrsIn, TAttrsOut>,\n      ) => StyledLiteral<Substitute<JSX.IntrinsicElements[Tag], TAttrsIn>>;\n    };\n  },\n  {\n    get(target, TagName: keyof JSX.IntrinsicElements) {\n      return target(TagName);\n    },\n  },\n);\n\n// Remove all entries that start with a $ sign\nfunction removePrefixedProperties<T extends Record<string, unknown>>(obj: T) {\n  const result = {} as T;\n  for (const key in obj) {\n    if (!key.startsWith(\"$\") && key !== \"theme\") {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\nconst mergeClassNames = (a?: string, b?: string) => {\n  if (!a) return b;\n  if (!b) return a;\n  return a + \" \" + b;\n};\n\nconst removeUndefined = <T,>(obj: T) => {\n  const result = {} as T;\n  for (const key in obj) {\n    if (obj[key] !== undefined) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n};\n\nconst combineProps = <\n  T extends {\n    className?: string;\n    style?: React.CSSProperties;\n  },\n>(\n  props: T,\n  newProps: T,\n) => {\n  if (!newProps) return props;\n  const combinedProps: T =\n    \"$__attrs\" in props\n      ? // allow overriding props when attrs was used previously\n        {\n          ...removeUndefined(newProps),\n          ...props,\n        }\n      : {\n          ...props,\n          ...removeUndefined(newProps),\n        };\n  return {\n    ...combinedProps,\n    className: mergeClassNames(\n      props.className as string,\n      newProps.className as string,\n    ),\n    style: { ...(props.style || {}), ...(newProps.style || {}) },\n    $__attrs: true,\n  };\n};\n\n// util type to remove properties from an object\ntype FastOmit<T extends object, U extends string | number | symbol> = {\n  [K in keyof T as K extends U ? never : K]: T[K];\n};\n\n// util type to merge two objects\n// if a property is present in both objects the property from B is used\nexport type Substitute<A extends object, B extends object> = FastOmit<\n  A,\n  keyof B\n> &\n  B;\n","/**\n * Allows to use atomic CSS classes in a styled or css block\n *\n * @usage\n *\n * ```tsx\n * import { styled, atoms } from \"next-yak\";\n *\n * const Button = styled.button<{ $primary?: boolean }>`\n *  ${atoms(\"text-teal-600\", \"text-base\", \"rounded-md\")}\n *  ${props => props.$primary && atoms(\"shadow-md\")}\n * `;\n * ```\n */\nexport const atoms = (...atoms: string[]) => {\n  const className = atoms.join(\" \");\n  return () => ({ className });\n};\n","/**\n * Allows to use CSS keyframe animations in a styled or css block\n *\n * @usage\n *\n * ```tsx\n * import { styled, keyframes } from \"next-yak\";\n *\n * const rotate = keyframes`\n *  from {\n *   transform: rotate(0deg);\n *  }\n *  to {\n *   transform: rotate(360deg);\n *  }\n * `;\n *\n * const Spinner = styled.div`\n *   animation: ${rotate} 1s linear infinite;\n * `;\n * ```\n */\nexport const keyframes = (\n  styles: TemplateStringsArray,\n  ...dynamic: never[]\n): string => {\n  // during compilation all args of keyframe are compiled\n  // to a string which references the animation name\n  return styles as any as string;\n};\n","export { css } from \"./cssLiteral.js\";\nexport { styled } from \"./styled.js\";\nexport { atoms } from \"./atoms.js\";\nexport { keyframes } from \"./keyframes.js\";\n\n// the following export is not relative as \"next-yak/context\"\n// links to one file for react server components and\n// to another file for classic react components\nexport { useTheme, YakThemeProvider } from \"next-yak/context\";\n\nexport type { YakTheme } from \"./context/index.d.ts\";\n"],"mappings":"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","names":["internalCssFactory","args","classNames","dynamicCssFunctions","style","arg","key","value","props","recursivePropExecution","className","allClassNames","allStyles","i","unwrapProps","fn","result","css","React","useTheme","yakForwardRef","component","StyledFactory","Component","yakStyled","attrs","styles","values","getRuntimeStyles","css","processAttrs","props","combineProps","ref","combinedProps","runtimeStyles","filteredProps","removePrefixedProperties","mergeClassNames","styled","target","TagName","obj","result","key","a","b","removeUndefined","newProps","atoms","className","keyframes","styles","dynamic","useTheme","YakThemeProvider"]}